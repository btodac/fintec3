#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed May 24 17:41:57 2023

@author: mtolladay
"""
import logging

import numpy as np
import pandas as pd

from agents.preprocessing import ObservationBuilder
from agents.targetgenerators import OrderBasedTargetGen
from utillities.timesanddates import get_ticker_time_zone, opening_and_closing_times

log = logging.getLogger(__name__)

# TODO: Convert sub classes to "model" class and use composition
#   The observers should not return numpy arrays but dataframes with column names and datetime index

PARAMS = {
    '^DJI': {
        # Position paramaters
        'take_profit': 75,
        'stop_loss': 20,
        'time_limit': 30,
        # Training params
        'up': 20,  # 20,
        'down': -20,  # 20,
        'to': 15,
    },
    "^NDX": {
        'take_profit': 30,#100
        'stop_loss': 2,
        'time_limit': 10,#15,
        'live_tp': 25,
        'live_sl': 5,
        'live_tl': 15,
    },
    '^GDAXI': {
        'take_profit': 25,
        'stop_loss': 5,
        'time_limit': 15,
        'live_tp': 25,
        'live_sl': 5,
        'live_tl': 10,
    },
    '^FCHI': {
        'take_profit': 17,
        'stop_loss': 4,
        'time_limit': 30,
        'up': 5,
        'down': -5,
        'to': 15,
    },
    '^FTSE': {
        'take_profit': 15,
        'stop_loss': 3,
        'time_limit': 30,
        'up': 10,
        'down': -10,
        'to': 30,
    },
    'EUR=X': {
        'take_profit': 30 * 1e-8,
        'stop_loss': 5 * 1e-8,
        'time_limit': 30,
        'up': 0.0005,
        'down': -0.0005,
        'to': 20,
    }
}


class Agent(object):
    '''
    This is an abstract base class that provides a standard interface,
    while allowing child classes to define fitting and predicting methods 
    (fit() and make_prediction()). The standard interface is used by 
    results generators or market agents to produce signals.
    '''
    
    def __init__(self, ticker: str, columns: list, model, params: dict=None, 
                 observer=None, target_generator=None):
        '''
        Parameters
        ----------
        ticker : str
            The ticker for the financial product
        columns : list
            A list of strings representing the features to be generated by
            the observer
        params : dict, optional
            A dict with entries:
                'take_profit' : the take profit distance
                'stop_loss' : stop loss distnace
                'time_limit' : time limit to keep a position open
                'live_tp' : the take profit distance when using in trading
                'live_sl' : live stop loss
                'live_tl' : ...
                'up' : a distance used in training to determine if the value
                    is increasing
                'down': similar to above
                'to' : the length of time to use in the direction determination
        observer : TYPE, optional
            This is a class with method make_observations(data), which
            generates the features of the model as a numpy array
        target_generator : TYPE, optional
            This is a class with method get_targets(data, order_datetimes),
            which returns a Nx3 numpy array with each row containing at least 
            one 1
        Returns
        -------
        None.

        '''

        self._params = {
            'ticker': ticker,
            'columns': columns,
            'tz': get_ticker_time_zone(ticker)
        }
        if params == None:
            self._params.update(PARAMS[ticker])
        else:
            self._params.update(params)
        
        self._set_tradeable_time(ticker)
        
        if observer is None:
            self.observer = ObservationBuilder(columns,)
        else:
            self.observer = observer
        if target_generator is None:
            self.target_generator = OrderBasedTargetGen(ticker, 
                                                        self._params['take_profit'], 
                                                        self._params['stop_loss'], 
                                                        self._params['time_limit']
                                                        )
        else:
            self.target_generator = target_generator
    
    def fit(self, training_data: pd.DataFrame, 
            validation_data: pd.DataFrame):
        '''
        Trains the agents model using provided data

        Parameters
        ----------
        training_data : pd.DataFrame
            Data used to fit the model
        validation_data : pd.DataFrame
            Data used to test the model

        Returns
        -------
        None.

        '''
        train_observations, train_targets, _ = self.get_observations_and_targets(training_data)
        val_observations, val_targets, _ = self.get_observations_and_targets(validation_data)
        self.model.fit(train_observations, train_targets, (val_observations, val_targets))
                   
    def __call__(self, data: pd.DataFrame) -> str:
        '''
        Used to generate a single class prediction

        Parameters
        ----------
        data : pd.DataFrame
            Raw OHLC data used to generate the observation

        Returns
        -------
        str
            Either "BUY","SELL" or "HOLD"

        '''
        observations, _ = self.observer.make_observations(data, self._opening_time, 
                                           self._closing_time, self._params['tz'])
        observation = observations[-1, :]
        pred = np.argmax(self.model.make_prediction(observation))
        return {0: 'BUY', 1: 'SELL', 2: 'HOLD'}[pred]

    def predict(self, data: pd.DataFrame,):
        '''
        This is the function users should call when wanting to make 
        a prediction.

        Parameters
        ----------
        data : pd.DataFrame
        The OHLC data for the financial product

        Returns
        -------
        pred : np.array
            has entries 0, 1 or 2 for every observation, representing
            buy, sell and hold
        prob : np.array
            an Nx3 array where each row represents the probabilty of 
            each class
        order_datetimes : pd.DatetimeIndex
            The corresponding datetimes for each prediction

        '''
        if data.index.tz != self._params['tz']:
            data.index = data.index.tz_convert(self._params['tz'])
        observations, order_datetimes = self.observer.make_observations(
            data, self._opening_time, self._closing_time, self._params['tz']
            )
        prob = self.model.make_prediction(observations)
        pred = np.argmax(prob, axis=1)
        return pred, prob, order_datetimes
    
    def get_observations_and_targets(self, data):
        '''
        This is a helper method to provide an easy way to generate
        observations, targets and corresponding datetimes that are 
        required for fitting procedures

        Parameters
        ----------
        data : pd.DataFrame
            Data used to derive observations and targets

        Returns
        -------
        observations : np.array
            an NxM array containing M features for N observations
        targets : np.array
            an Nx3 array containing the exact values used for fitting
        order_datetimes : pd.DatetimeIndex
            The corresponding datetimes for the observations/targets

        '''
        if data.index.tz != self._params['tz']:
            data.index = data.index.tz_convert(self._params['tz'])
        observations, order_datetimes = self.observer.make_observations(
            data,self._opening_time, self._closing_time, self._params['tz']
           )
        targets = self.target_generator.get_targets(data, order_datetimes)
        return observations, targets, order_datetimes
    
    def _set_tradeable_time(self, ticker,):
        opening_time, closing_time = opening_and_closing_times(ticker)
        opening_time = opening_time.tz_convert(self._params['tz'])
        closing_time = closing_time.tz_convert(self._params['tz'])
        if not np.isnan(self._params['to']):
            closing_time -= pd.Timedelta(minutes=self._params['to'])
        else:
            closing_time -= pd.Timedelta(minutes=1)
        self._opening_time = opening_time
        self._closing_time = closing_time
        
    def __reduce__(self):
        args_kwargs = (self._params['ticker'], self._params['columns'],
                       self.model, self._params, self.observer, 
                       self.target_generator)
        
        return type(self), args_kwargs
        
